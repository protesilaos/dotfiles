#!/bin/bash

	# This program is free software: you can redistribute it and/or modify
	# it under the terms of the GNU General Public License as published by
	# the Free Software Foundation, either version 3 of the License, or
	# (at your option) any later version.

	# This program is distributed in the hope that it will be useful,
	# but WITHOUT ANY WARRANTY; without even the implied warranty of
	# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	# GNU General Public License for more details.

	# You should have received a copy of the GNU General Public License
	# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Description
# -----------
#
# Melonpanel: my `lemonbar` implementation, for use in my custom desktop
# session (see my dotfiles https://gitlab.com/protesilaos/dotfiles).
# I just selected the name "melon" as an anagram for "lemon" and then
# switched "bar" with "panel".  This is to avoid naming conflicts where
# we could accidentally kill the wrong process or whatnot.
#
# Debian Buster dependencies for melonpanel:
#	apt install bspwm lemonbar xdo
#
# Dependencies for individual modules:
# 	apt install amixer mpd mpc
#
# Optional:
# 	apt install xfonts-terminus
#
# Last full review 2019-05-13

# General settings
# ----------------

# Check if any lemonbar is running and kill it
if pgrep -xo lemonbar > /dev/null; then
	pkill -xo lemonbar
fi

# Melonpanel variables
melonpanel_height=22
# NOTE smaller font sizes are poor fits for light themes: a halo effect
# is created around glyphs, while colours are harder to tell apart.
if [ -n "$(fc-list terminus)" ]; then
	# NOTE the descriptions for the Terminus typeface are copied from
	# /etc/X11/fonts/misc/xfonts-terminus.alias
	# A wildcard `*` can replace each part of the definition.
	melonpanel_font='-xos4-terminus-medium-r-normal--16-160-72-72-c-80-iso10646-1'
else
	# Could not find this exact definition in the Debian configs.  Got
	# it from here: https://www.cl.cam.ac.uk/~mgk25/ucs-fonts.html
	melonpanel_font='-misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1'
fi

# Colours for modules and bspwm indicators
# ----------------------------------------

# Add colours from current Tempus theme.  That file is used in other
# places as well to offer a convenient way of styling multiple tools in
# a manner that is centralised and straightforward.  Colour definitions
# are "color[0-15]", using the standard terminal sequence, plus
# "foreground{alt}", "background{alt,dim}".  For details, see the main
# Tempus themes repo: https://gitlab.com/protesilaos/tempus-themes
source "$HOME/.local/share/my_colours/active-tempus-theme.sh"

# Panel modules
# -------------
#
# NOTE all functions that are meant to pipe their output to the panel
# will echo a majuscule (letter A-Z).  This is done to easily retrieve
# their output from the named pipe.  The letter has to be unique and,
# ideally, use common words that denote the function of the content of
# the command such as e.g. D for Date, N for Network...  Where this
# would lead to conflicts, find a synonym or something close enough.

# Battery status: charging (c), discharging (d), full (f), unknown (?).
battery_status() {
	local battery_path battery_status battery_label battery_output

	battery_path='/sys/class/power_supply/BAT0'
	battery_output="$(sed 1q $battery_path/capacity)"
	battery_status="$(sed 1q $battery_path/status)"
	battery_label='Bat'

	if [ -d "$battery_path" ]; then
		case "$battery_status" in
			'Charging')
				echo "%{F$color14}$battery_label <c>%{F-} ${battery_output}%"
				;;
			'Discharging')
				case "$battery_output" in
					1[0-9])
						echo "%{F$color1}$battery_label <d>%{F-} ${battery_output}%"
						;;
					[0-9])
						echo "%{B$color1}%{F$background} $battery_label ${battery_output}% %{F-}%{B-}"
						;;
					*)
						echo "%{F$color11}$battery_label <d>%{F-} ${battery_output}%"
						;;
				esac
				;;
			'Full')
				echo "%{F$color2}$battery_label%{F-} Full"
				;;
			*)
				echo "%{F$color3}$battery_label <?>%{F-} ${battery_output}%"
				;;
		esac
	else
		echo ''
	fi
}

# Check if the volume is muted or not.  Output the appropriate
# indicators.
volume_status() {
	if [ "$(command -v amixer 2> /dev/null)" ]; then
		local volume_status volume_level volume_label

		amixer_get() {
			amixer get Master | \
			sed "/^\ *Front R/!d ; s,\(^.*\) \[\(.*%\)\] \[\(.*\)\],\\${1},"
		}

		volume_status="$(amixer_get 3)"
		volume_level="$(amixer_get 2)"
		volume_label='Vol'

		case "$volume_status" in
			'off')
				echo "%{F$color3}$volume_label%{F-}" "$volume_level (Muted)"
				;;
			'on')
				echo "%{F$color4}$volume_label%{F-}" "$volume_level"
				;;
			*)
				echo ''
				;;
		esac
	fi
}

# Get the status of the Music Player Daemon.
mpd_status() {
	local mpc_status current_song maxlen

	mpc_status="$(mpc status | grep -o '^\[[a-z]*\]')"
	current_song="$(mpc current -f "[[%artist%: ]%title%]|[%file%]")"
	maxlen=30

	mpd_playing() {
		case "$mpc_status" in
			'[playing]')
				echo "%{F$color5}>>%{F-}"
				;;
			'[paused]')
				echo "%{F$color5}||%{F-}"
				;;
			*)
				echo ''
				;;
		esac
	}

	# if playing or paused
	if [ -n "$mpc_status" ]; then
		# Check if current mpc status has a length that is equal or
		# higher than "$maxlen".  If so trim the output and append
		# marker to denote the modification.
		if [ "${#current_song}" -ge "$maxlen" ]; then
			echo "$(mpd_playing)" "${current_song:0:$maxlen}" "[..]"
		else
			echo "$(mpd_playing)" "$current_song"
		fi
	fi
}

# Modified version of the content of `own_script_current_layout`.  That
# is a separate file just because I need the functionality decoupled
# from the panel.  All we do here is print the language of the current
# layout.
keyboard_layout() {
	if [ "$(setxkbmap -query | sed '/^layout/!d ; s,^.*:[\ ]*,,g')" == 'gr' ]; then
		echo "%{U$foregroundalt}%{+u}EL%{-u}%{U-}" # Greek
	else
		echo 'EN' # English (US QWERTY)
	fi
}

# Include all modules in a single infinite loop that iterates every
# second (adjust interval accordingly, as it can be taxing on system
# resources).
#
# To format the date, see `man date`.
my_modules() {
	while true; do
		echo "B" "$(battery_status)"
		echo "D" "$(date +'%a %-d %b %H:%M')"
		echo "K" "$(keyboard_layout)"
		echo "M" "$(mpd_status)"
		echo "V" "$(volume_status)"
		sleep 1s
	done
}

# Piping and reading the output of the modules
# --------------------------------------------

# The design of this section has been heavily inspired/adapted from the
# examples provided by upstream bspwm.

# set path to named pipe used to store process data for these operations
melonpanel_fifo=/tmp/melonpanel_fifo

# make sure you delete any existing named pipe
if [ -e "$melonpanel_fifo" ]; then
	rm "$melonpanel_fifo"
fi

# create a new named pipe
mkfifo "$melonpanel_fifo"

# pipe the output of the modules to the fifo
my_modules > "$melonpanel_fifo" &
bspc subscribe report > "$melonpanel_fifo" &

# Read the content of the fifo file.  We differantiate between modules
# based on the majuscule (letter A-Z) they piped into melonpanel_fifo
# (see modules above).  Here we just add a shorter variable to each
# module, which helps position it on the panel (the last printf).
melonpanel() {
	local num_mon laptop_external_monitor

	num_mon="$(bspc query -M | wc -l)"
	laptop_external_monitor="$(xrandr --query | grep 'VGA1 connected')"

	while read -r line ; do
		case $line in
			B*)
				# battery status
				bat="${line#?}"
				;;
			D*)
				# current date and time
				date="${line#?}"
				;;
			K*)
				# keyboard layout (en or gr)
				key="${line#?}"
				;;
			M*)
				# MPD
				mpd="${line#?}"
				;;
			V*)
				# volume level
				vol="${line#?}"
				;;
			W*)
				# bspwm's state
				wm=
				IFS=':'
				set -- ${line#?}
				while [ "$#" -gt 0 ] ; do
					item="$1"
					name="${item#?}"
					case "$item" in
						[mMfFoOuULG]*)
							case "$item" in
								m*)
									# monitor
									on_focused_monitor=
									name=
									;;
								M*)
									# focused monitor
									on_focused_monitor=1
									name=
									;;
								# {Free,Occupied,Urgent} focused
								[FOU]*)
									if [ -n "$on_focused_monitor" ]; then
										name="${name/*/[$name*]}"
										FG="$foreground"
									else
										name="${name/*/ $name- }"
										FG="$foregroundalt"
									fi
									;;
								# {free,occupied,urgent} unfocused
								f*)
									FG="$foregroundalt"
									name="${name/*/ $name  }"
									;;
								o*)
									FG="$foregroundalt"
									name="${name/*/ $name^ }"
									;;
								u*)
									FG="$color1"
									name="${name/*/ $name\# }"
									;;
								# desktop layout for monocle and node flags
								LM|G*?)
									FG="$foreground"
									name="${name/*/ $name }"
									;;
								*)
									FG="$foregroundalt"
									name="${name/*/ Â· }"
									;;
							esac
							wm="${wm}%{F$FG}${name}%{F-}"
							;;
					esac
					shift
				done
		esac

		panel_layout() {
			echo "%{l}$wm%{r}$mpd $bat $vol $key $date "
		}

		if [ -n "$laptop_external_monitor" ]; then
			printf "%s%s\n" "%{Sf}$(panel_layout)" "%{Sl}$(panel_layout)"
		else
			printf "%s\n" "%{Sf}$(panel_layout)"
		fi
	done
}

# Launch the panel with the given parameters
# ------------------------------------------

# NOTE the syntax for the background value.  If you want transparency,
# just replace "ff" with a lower value: "00" means no opacity.  This is
# hexadecimal notation.
melonpanel < "$melonpanel_fifo" | lemonbar -u 1 -p -g "x${melonpanel_height}" \
-F "$foreground" -B "#ff${background:1}" -f "$melonpanel_font" -n "Melonpanel" &

# Hide panel when windows are in full screen mode.  This does not work
# all the time, especially with lower `sleep` values, requiring a
# re-launch of melonpanel (pkill -x melonpanel && melonpanel).  I have
# yet to find a robust solution.
#
# Source of this snippet (with minor adapatations by me):
# https://github.com/baskerville/bspwm/issues/484
until bar_id=$(xdo id -a 'Melonpanel'); do
	sleep 1s
done

xdo below -t $(xdo id -n root) $bar_id &
